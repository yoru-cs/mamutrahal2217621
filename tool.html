<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Data Analysis Tool</title>
  <!-- Futuristic Font -->
  <link href="https://fonts.googleapis.com/css?family=Orbitron" rel="stylesheet">
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
  <!-- Chart.js for visualizations -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* Body with animated dark gradient background */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Orbitron', sans-serif;
      background: linear-gradient(-45deg, #001f3f, #2e8b8b, #001f3f, #0f52ba);
      background-size: 400% 400%;
      animation: gradientBG 15s ease infinite;
      color: #e0f7fa;
    }
    @keyframes gradientBG {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    /* Main container */
    .container {
      width: 95%;
      max-width: 1400px;
      margin: 30px auto;
      background-color: #001f3f;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 30px rgba(15, 82, 186, 0.3);
    }
    h1, h2 {
      text-align: center;
      margin-bottom: 20px;
      color: #e0f7fa;
    }
    /* File input */
    .file-input {
      display: flex;
      justify-content: center;
      margin-bottom: 30px;
    }
    input[type="file"] {
      background-color: #0f52ba;
      border: 2px solid #2e8b8b;
      border-radius: 4px;
      padding: 10px;
      color: #e0f7fa;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    input[type="file"]:hover {
      background-color: #2e8b8b;
    }
    /* Navigation Tabs */
    .tabs {
      position: relative;
      z-index: 10;
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .tab {
      background-color: #0f52ba;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: transform 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
      color: #e0f7fa;
      font-weight: bold;
    }
    .tab:hover,
    .tab.active {
      transform: scale(1.05);
      border-color: #2e8b8b;
      box-shadow: 0 0 8px #2e8b8b;
    }
    /* Section styling */
    .section {
      display: none;
      animation: fadeIn 0.5s;
    }
    .section.active {
      display: block;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    /* Card styling for analysis/calculations */
    .analysis-card, .calc-card {
      background-color: #0f52ba;
      margin: 10px 0;
      border-left: 4px solid #2e8b8b;
      padding: 15px;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    .analysis-card:hover, .calc-card:hover {
      transform: scale(1.02);
    }
    .analysis-summary, .calc-summary {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .analysis-details, .calc-details {
      display: none;
      margin-top: 10px;
      font-size: 0.9em;
      color: #e0f7fa;
    }
    .info-btn, .toggle-btn {
      background: none;
      border: none;
      color: #2e8b8b;
      cursor: pointer;
      font-size: 0.9em;
      transition: color 0.3s;
    }
    .info-btn:hover, .toggle-btn:hover {
      color: #0f52ba;
    }
    /* Chart containers */
    .chart-container {
      margin: 20px auto;
      padding: 10px;
      background-color: #001f3f;
      border-radius: 4px;
    }
    canvas {
      display: block;
      margin: auto;
    }
    /* Form elements */
    .form-group {
      margin: 15px 0;
    }
    label {
      margin-right: 10px;
    }
    select, button, input[type="text"] {
      padding: 6px 10px;
      border-radius: 4px;
      border: none;
      margin-right: 10px;
      font-family: 'Orbitron', sans-serif;
    }
    button {
      background-color: #2e8b8b;
      color: #001f3f;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #0f52ba;
    }
    /* Raw Data Table */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      font-size: 0.9em;
      background-color: #0f52ba;
    }
    th, td {
      padding: 8px;
      border: 1px solid #2e8b8b;
      text-align: center;
    }
    th {
      background-color: #2e8b8b;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Data Analysis Tool</h1>
    <div class="file-input">
      <input type="file" id="csvFileInput" accept=".csv">
    </div>
    <!-- Navigation Tabs (Raw Data Preview now first) -->
    <div class="tabs">
      <button class="tab active" data-tab="raw">Raw Data Preview</button>
      <button class="tab" data-tab="logistics">Logistics Calculations</button>
      <button class="tab" data-tab="descriptive">Descriptive Statistics</button>
      <button class="tab" data-tab="correlation">Correlation Analysis</button>
      <button class="tab" data-tab="custom">Custom Visualization</button>
    </div>
    <!-- Raw Data Preview Section -->
    <div id="raw" class="section active">
      <h2>Raw Data Preview</h2>
      <div id="rawDataTable"></div>
    </div>
    <!-- Logistics Calculations Section -->
    <div id="logistics" class="section">
      <h2>Logistics Calculations</h2>
      <!-- Card 1: Highest Average Lead Time by Supplier -->
      <div class="calc-card" id="calc-highestSupplier">
        <div class="calc-summary">
          <h3>Highest Average Lead Time by Supplier</h3>
          <button class="toggle-btn">Show Details ▼</button>
        </div>
        <button class="calc-btn" data-calc="highestSupplier">Calculate</button>
        <button class="chart-btn" data-chart="supplier">Show Chart</button>
        <div class="calc-result"></div>
        <div class="calc-details">
          <p><strong>Formula:</strong> Average Lead Time = Σ(Actual Delivery Date − Order Date) / Number of Orders</p>
          <p>This metric identifies which supplier takes the longest on average to deliver goods.</p>
        </div>
        <div class="chart-container">
          <canvas id="chart-highestSupplier" width="400" height="200"></canvas>
        </div>
      </div>
      <!-- Card 2: Lowest Average Lead Time by Transportation Mode -->
      <div class="calc-card" id="calc-lowestTransport">
        <div class="calc-summary">
          <h3>Lowest Average Lead Time by Transportation Mode</h3>
          <button class="toggle-btn">Show Details ▼</button>
        </div>
        <button class="calc-btn" data-calc="lowestTransport">Calculate</button>
        <button class="chart-btn" data-chart="transport">Show Chart</button>
        <div class="calc-result"></div>
        <div class="calc-details">
          <p><strong>Formula:</strong> Average Lead Time = Σ(Actual Delivery Date − Order Date) / Number of Orders (grouped by transportation mode)</p>
          <p>This shows which transportation method delivers fastest on average.</p>
        </div>
        <div class="chart-container">
          <canvas id="chart-lowestTransport" width="400" height="200"></canvas>
        </div>
      </div>
      <!-- Card 3: Month with Highest Average Delivery Delay -->
      <div class="calc-card" id="calc-highestMonthDelay">
        <div class="calc-summary">
          <h3>Month with Highest Average Delivery Delay</h3>
          <button class="toggle-btn">Show Details ▼</button>
        </div>
        <button class="calc-btn" data-calc="highestMonthDelay">Calculate</button>
        <button class="chart-btn" data-chart="month">Show Chart</button>
        <div class="calc-result"></div>
        <div class="calc-details">
          <p><strong>Formula:</strong> Average Delay = Σ(Actual Delivery Date − Expected Delivery Date) / Number of Orders (grouped by month)</p>
          <p>This calculates delays in delivery and identifies the month with the greatest average delay.</p>
        </div>
        <div class="chart-container">
          <canvas id="chart-highestMonthDelay" width="400" height="200"></canvas>
        </div>
      </div>
      <!-- Card 4: Disruption Type with Longest Average Delay -->
      <div class="calc-card" id="calc-longestDisruption">
        <div class="calc-summary">
          <h3>Disruption Type with Longest Average Delay</h3>
          <button class="toggle-btn">Show Details ▼</button>
        </div>
        <button class="calc-btn" data-calc="longestDisruption">Calculate</button>
        <button class="chart-btn" data-chart="disruption">Show Chart</button>
        <div class="calc-result"></div>
        <div class="calc-details">
          <p><strong>Formula:</strong> Average Delay = Σ(Actual Delivery Date − Expected Delivery Date) / Number of Orders (for each disruption type, excluding “None”)</p>
          <p>This indicates which type of disruption causes the greatest delays.</p>
        </div>
        <div class="chart-container">
          <canvas id="chart-longestDisruption" width="400" height="200"></canvas>
        </div>
      </div>
      <!-- Card 5: Product Category with Shortest Average Lead Time -->
      <div class="calc-card" id="calc-shortestProduct">
        <div class="calc-summary">
          <h3>Product Category with Shortest Average Lead Time</h3>
          <button class="toggle-btn">Show Details ▼</button>
        </div>
        <button class="calc-btn" data-calc="shortestProduct">Calculate</button>
        <button class="chart-btn" data-chart="product">Show Chart</button>
        <div class="calc-result"></div>
        <div class="calc-details">
          <p><strong>Formula:</strong> Average Lead Time = Σ(Actual Delivery Date − Order Date) / Number of Orders (grouped by product category)</p>
          <p>This metric highlights which product category is procured most efficiently.</p>
        </div>
        <div class="chart-container">
          <canvas id="chart-shortestProduct" width="400" height="200"></canvas>
        </div>
      </div>
      <!-- Card 6: Overall Lead Time Variability -->
      <div class="calc-card" id="calc-overallLeadTimeVar">
        <div class="calc-summary">
          <h3>Overall Lead Time Variability</h3>
          <button class="toggle-btn">Show Details ▼</button>
        </div>
        <button class="calc-btn" data-calc="overallLeadTimeVar">Calculate</button>
        <div class="calc-result"></div>
        <div class="calc-details">
          <p><strong>Formula:</strong> Standard Deviation of Lead Time across all orders</p>
          <p>This metric represents the overall fluctuation in supplier delivery times.</p>
        </div>
      </div>
      <!-- Card 7: Transportation Mode with Highest Average Delivery Delay -->
      <div class="calc-card" id="calc-highestTransportDelay">
        <div class="calc-summary">
          <h3>Transportation Mode with Highest Average Delivery Delay</h3>
          <button class="toggle-btn">Show Details ▼</button>
        </div>
        <button class="calc-btn" data-calc="highestTransportDelay">Calculate</button>
        <div class="calc-result"></div>
        <div class="calc-details">
          <p><strong>Formula:</strong> Average Delay = Σ(Actual Delivery Date − Expected Delivery Date) / Number of Orders (grouped by transportation mode)</p>
          <p>This identifies which transportation method is most prone to delays.</p>
        </div>
      </div>
      <!-- Card 8: Month with Highest Average Lead Time -->
      <div class="calc-card" id="calc-highestLeadTimeMonth">
        <div class="calc-summary">
          <h3>Month with Highest Average Lead Time</h3>
          <button class="toggle-btn">Show Details ▼</button>
        </div>
        <button class="calc-btn" data-calc="highestLeadTimeMonth">Calculate</button>
        <div class="calc-result"></div>
        <div class="calc-details">
          <p><strong>Formula:</strong> Average Lead Time = Σ(Actual Delivery Date − Order Date) / Number of Orders (grouped by month)</p>
          <p>This reveals seasonal trends affecting lead times.</p>
        </div>
      </div>
      <!-- Card 9: Bullwhip Effect Analysis -->
      <div class="calc-card" id="calc-bullwhip">
        <div class="calc-summary">
          <h3>Bullwhip Effect Analysis</h3>
          <button class="toggle-btn">Show Details ▼</button>
        </div>
        <button class="calc-btn" data-calc="bullwhip">Calculate</button>
        <div class="calc-result"></div>
        <div class="calc-details">
          <p>This analysis compares the coefficient of variation (CV) of order quantities and customer demand by month.</p>
          <p>A higher ratio (CV(Order Qty) / CV(Customer Demand)) suggests an amplified variability (bullwhip effect).</p>
        </div>
      </div>
      <!-- Card 10: Correlation Between Order Qty Variability and Lead Time Variability -->
      <div class="calc-card" id="calc-corrOrderLeadVar">
        <div class="calc-summary">
          <h3>Correlation: Order Qty Variability vs. Lead Time Variability</h3>
          <button class="toggle-btn">Show Details ▼</button>
        </div>
        <button class="calc-btn" data-calc="corrOrderLeadVar">Calculate</button>
        <div class="calc-result"></div>
        <div class="calc-details">
          <p>This computes the Pearson correlation coefficient between the standard deviation of order quantities and the standard deviation of lead times across suppliers.</p>
        </div>
      </div>
    </div>
    <!-- Descriptive Statistics Section -->
    <div id="descriptive" class="section">
      <h2>Descriptive Statistics</h2>
      <div class="form-group">
        <label for="descColumnSelect">Select Numeric Column:</label>
        <select id="descColumnSelect"></select>
        <button id="computeStats">Compute Stats</button>
      </div>
      <div id="descResults"></div>
    </div>
    <!-- Correlation Analysis Section -->
    <div id="correlation" class="section">
      <h2>Correlation Analysis</h2>
      <div class="form-group">
        <label for="corrXSelect">X-Axis:</label>
        <select id="corrXSelect"></select>
        <label for="corrYSelect">Y-Axis:</label>
        <select id="corrYSelect"></select>
        <button id="computeCorr">Compute Correlation</button>
      </div>
      <div id="corrResults"></div>
      <div class="chart-container">
        <canvas id="chart-correlation" width="400" height="200"></canvas>
      </div>
    </div>
    <!-- Custom Visualization Section -->
    <div id="custom" class="section">
      <h2>Custom Visualization</h2>
      <div class="form-group">
        <label for="chartTypeSelect">Chart Type:</label>
        <select id="chartTypeSelect">
          <option value="bar">Bar</option>
          <option value="line">Line</option>
          <option value="scatter">Scatter</option>
          <option value="histogram">Histogram</option>
        </select>
        <label for="customXSelect">X-Axis:</label>
        <select id="customXSelect"></select>
        <label for="customYSelect">Y-Axis:</label>
        <select id="customYSelect"></select>
        <button id="generateChart">Generate Chart</button>
      </div>
      <div class="chart-container">
        <canvas id="chart-custom" width="400" height="200"></canvas>
      </div>
    </div>
  </div>
  <script>
    // Global variables
    var parsedData = [];
    var numericColumns = ["Order_Quantity", "Customer_Demand"];
    var chartInstances = {};

    // Utility: calculate difference in days between two dates
    function dateDiffInDays(a, b) {
      var _MS_PER_DAY = 1000 * 60 * 60 * 24;
      var utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
      var utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());
      return Math.floor((utc2 - utc1) / _MS_PER_DAY);
    }

    // When DOM is ready, attach event listeners
    document.addEventListener("DOMContentLoaded", function() {
      // Tab switching
      var tabs = document.querySelectorAll(".tab");
      tabs.forEach(function(tab) {
        tab.addEventListener("click", function() {
          var target = tab.getAttribute("data-tab");
          tabs.forEach(function(t) { t.classList.remove("active"); });
          document.querySelectorAll(".section").forEach(function(sec) { sec.classList.remove("active"); });
          tab.classList.add("active");
          document.getElementById(target).classList.add("active");
        });
      });
      
      // File upload event
      document.getElementById("csvFileInput").addEventListener("change", function(e) {
        var file = e.target.files[0];
        if (!file) return;
        Papa.parse(file, {
          header: true,
          dynamicTyping: true,
          complete: function(results) {
            parsedData = results.data.filter(function(row) {
              return Object.keys(row).length > 1;
            });
            processData(parsedData);
            populateDropdowns();
            renderRawData();
          },
          error: function(err) {
            alert("Error parsing file: " + err);
          }
        });
      });
      
      // Logistics Calculation buttons
      document.querySelectorAll(".calc-btn").forEach(function(btn) {
        btn.addEventListener("click", function() {
          var calcType = btn.getAttribute("data-calc");
          if (calcType === "highestSupplier") {
            calcHighestSupplier();
          } else if (calcType === "lowestTransport") {
            calcLowestTransportation();
          } else if (calcType === "highestMonthDelay") {
            calcHighestMonthDelay();
          } else if (calcType === "longestDisruption") {
            calcLongestDisruptionDelay();
          } else if (calcType === "shortestProduct") {
            calcShortestProductLead();
          } else if (calcType === "overallLeadTimeVar") {
            calcOverallLeadTimeVar();
          } else if (calcType === "highestTransportDelay") {
            calcHighestTransportDelay();
          } else if (calcType === "highestLeadTimeMonth") {
            calcHighestLeadTimeMonth();
          } else if (calcType === "bullwhip") {
            calcBullwhipEffect();
          } else if (calcType === "corrOrderLeadVar") {
            calcCorrOrderLeadVar();
          }
        });
      });
      
      // Logistics Chart buttons
      document.querySelectorAll(".chart-btn").forEach(function(btn) {
        btn.addEventListener("click", function() {
          var chartType = btn.getAttribute("data-chart");
          showChart(chartType);
        });
      });
      
      // Toggle details for calculation cards
      document.querySelectorAll(".toggle-btn").forEach(function(btn) {
        btn.addEventListener("click", function() {
          var card = btn.closest(".calc-card");
          var details = card.querySelector(".calc-details");
          if (details.style.display === "block") {
            details.style.display = "none";
            btn.textContent = "Show Details ▼";
          } else {
            details.style.display = "block";
            btn.textContent = "Hide Details ▲";
          }
        });
      });
      
      // Descriptive statistics event – display in table format
      document.getElementById("computeStats").addEventListener("click", function() {
        var col = document.getElementById("descColumnSelect").value;
        var stats = computeDescriptiveStats(col);
        if (stats) {
          var tableHTML = "<table><tr><th>Statistic</th><th>Value</th></tr>";
          tableHTML += "<tr><td>Count</td><td>" + stats.count + "</td></tr>";
          tableHTML += "<tr><td>Mean</td><td>" + stats.mean.toFixed(2) + "</td></tr>";
          tableHTML += "<tr><td>Median</td><td>" + stats.median.toFixed(2) + "</td></tr>";
          tableHTML += "<tr><td>Mode</td><td>" + stats.mode + "</td></tr>";
          tableHTML += "<tr><td>Std Deviation</td><td>" + stats.stdDev.toFixed(2) + "</td></tr>";
          tableHTML += "</table>";
          document.getElementById("descResults").innerHTML = tableHTML;
        }
      });
      
      // Correlation analysis event – also generate scatter chart with regression line
      document.getElementById("computeCorr").addEventListener("click", function() {
        var xCol = document.getElementById("corrXSelect").value;
        var yCol = document.getElementById("corrYSelect").value;
        var corr = computeCorrelation(xCol, yCol);
        var resultText = "";
        if (corr !== null) {
          resultText = "Pearson Correlation: " + corr.toFixed(3);
        } else {
          resultText = "Insufficient numeric data.";
        }
        document.getElementById("corrResults").innerHTML = resultText;
        generateCorrelationChart(xCol, yCol);
      });
      
      // Custom visualization event
      document.getElementById("generateChart").addEventListener("click", function() {
        generateCustomChart();
      });
    });
    
    // Data processing: compute LeadTime and Delay for each row
    function processData(data) {
      data.forEach(function(row) {
        if (row.Order_Date && row.Actual_Delivery_Date) {
          var orderDate = new Date(row.Order_Date);
          var actualDate = new Date(row.Actual_Delivery_Date);
          if (!isNaN(orderDate) && !isNaN(actualDate)) {
            row.LeadTime = dateDiffInDays(orderDate, actualDate);
          }
        }
        if (row.Expected_Delivery_Date && row.Actual_Delivery_Date) {
          var expectedDate = new Date(row.Expected_Delivery_Date);
          var actualDate = new Date(row.Actual_Delivery_Date);
          if (!isNaN(expectedDate) && !isNaN(actualDate)) {
            row.Delay = dateDiffInDays(expectedDate, actualDate);
          }
        }
      });
      if (numericColumns.indexOf("LeadTime") === -1) numericColumns.push("LeadTime");
      if (numericColumns.indexOf("Delay") === -1) numericColumns.push("Delay");
    }
    
    // Populate dropdowns with numeric columns
    function populateDropdowns() {
      var selects = [document.getElementById("descColumnSelect"),
                     document.getElementById("corrXSelect"),
                     document.getElementById("corrYSelect"),
                     document.getElementById("customXSelect"),
                     document.getElementById("customYSelect")];
      selects.forEach(function(select) {
        select.innerHTML = "";
        numericColumns.forEach(function(col) {
          var option = document.createElement("option");
          option.value = col;
          option.textContent = col;
          select.appendChild(option);
        });
      });
    }
    
    // Render Raw Data Table (first 50 rows)
    function renderRawData() {
      var tableDiv = document.getElementById("rawDataTable");
      if (!parsedData.length || !parsedData[0]) {
        tableDiv.innerHTML = "No data available.";
        return;
      }
      var html = "<table><thead><tr>";
      var headers = Object.keys(parsedData[0]);
      headers.forEach(function(header) {
        html += "<th>" + header + "</th>";
      });
      html += "</tr></thead><tbody>";
      parsedData.slice(0, 50).forEach(function(row) {
        html += "<tr>";
        headers.forEach(function(header) {
          html += "<td>" + row[header] + "</td>";
        });
        html += "</tr>";
      });
      html += "</tbody></table>";
      tableDiv.innerHTML = html;
    }
    
    /* ------------------ Logistics Calculation Functions ------------------ */
    
    // Card 1: Highest Average Lead Time by Supplier
    function calcHighestSupplier() {
      var supplierData = {};
      parsedData.forEach(function(row) {
        if (row.Supplier && row.Order_Date && row.Actual_Delivery_Date) {
          var orderDate = new Date(row.Order_Date);
          var actualDate = new Date(row.Actual_Delivery_Date);
          if (!isNaN(orderDate) && !isNaN(actualDate)) {
            var leadTime = dateDiffInDays(orderDate, actualDate);
            if (!supplierData[row.Supplier]) {
              supplierData[row.Supplier] = { total: 0, count: 0 };
            }
            supplierData[row.Supplier].total += leadTime;
            supplierData[row.Supplier].count += 1;
          }
        }
      });
      var avgSupplier = {};
      Object.keys(supplierData).forEach(function(sup) {
        avgSupplier[sup] = supplierData[sup].total / supplierData[sup].count;
      });
      var keys = Object.keys(avgSupplier);
      if (keys.length === 0) {
        document.querySelector("#calc-highestSupplier .calc-result").innerHTML = "No data available.";
        return;
      }
      var highestSupplier = keys.reduce(function(a, b) { return avgSupplier[a] > avgSupplier[b] ? a : b; });
      var resultText = "Supplier: " + highestSupplier + " (Avg Lead Time: " + avgSupplier[highestSupplier].toFixed(2) + " days)";
      document.querySelector("#calc-highestSupplier .calc-result").innerHTML = resultText;
    }
    
    // Card 2: Lowest Average Lead Time by Transportation Mode
    function calcLowestTransportation() {
      var transportData = {};
      parsedData.forEach(function(row) {
        if (row.Transportation_Mode && row.Order_Date && row.Actual_Delivery_Date) {
          var orderDate = new Date(row.Order_Date);
          var actualDate = new Date(row.Actual_Delivery_Date);
          if (!isNaN(orderDate) && !isNaN(actualDate)) {
            var leadTime = dateDiffInDays(orderDate, actualDate);
            if (!transportData[row.Transportation_Mode]) {
              transportData[row.Transportation_Mode] = { total: 0, count: 0 };
            }
            transportData[row.Transportation_Mode].total += leadTime;
            transportData[row.Transportation_Mode].count += 1;
          }
        }
      });
      var avgTransport = {};
      Object.keys(transportData).forEach(function(mode) {
        avgTransport[mode] = transportData[mode].total / transportData[mode].count;
      });
      var keys = Object.keys(avgTransport);
      if (keys.length === 0) {
        document.querySelector("#calc-lowestTransport .calc-result").innerHTML = "No data available.";
        return;
      }
      var lowestTransport = keys.reduce(function(a, b) { return avgTransport[a] < avgTransport[b] ? a : b; });
      var resultText = "Transportation Mode: " + lowestTransport + " (Avg Lead Time: " + avgTransport[lowestTransport].toFixed(2) + " days)";
      document.querySelector("#calc-lowestTransport .calc-result").innerHTML = resultText;
    }
    
    // Card 3: Month with Highest Average Delivery Delay
    function calcHighestMonthDelay() {
      var monthData = {};
      parsedData.forEach(function(row) {
        if (row.Expected_Delivery_Date && row.Actual_Delivery_Date) {
          var expectedDate = new Date(row.Expected_Delivery_Date);
          var actualDate = new Date(row.Actual_Delivery_Date);
          if (!isNaN(expectedDate) && !isNaN(actualDate)) {
            var delay = dateDiffInDays(expectedDate, actualDate);
            var month = expectedDate.toLocaleString("en-US", { month: "long" });
            if (!monthData[month]) {
              monthData[month] = { total: 0, count: 0 };
            }
            monthData[month].total += delay;
            monthData[month].count += 1;
          }
        }
      });
      var avgMonth = {};
      Object.keys(monthData).forEach(function(month) {
        avgMonth[month] = monthData[month].total / monthData[month].count;
      });
      var keys = Object.keys(avgMonth);
      if (keys.length === 0) {
        document.querySelector("#calc-highestMonthDelay .calc-result").innerHTML = "No data available.";
        return;
      }
      var highestMonth = keys.reduce(function(a, b) { return avgMonth[a] > avgMonth[b] ? a : b; });
      var resultText = "Month: " + highestMonth + " (Avg Delay: " + avgMonth[highestMonth].toFixed(2) + " days)";
      document.querySelector("#calc-highestMonthDelay .calc-result").innerHTML = resultText;
    }
    
    // Card 4: Disruption Type with Longest Average Delay
    function calcLongestDisruptionDelay() {
      var disruptionData = {};
      parsedData.forEach(function(row) {
        if (row.Disruption_Type && row.Disruption_Type.toLowerCase() !== "none" && row.Expected_Delivery_Date && row.Actual_Delivery_Date) {
          var expectedDate = new Date(row.Expected_Delivery_Date);
          var actualDate = new Date(row.Actual_Delivery_Date);
          if (!isNaN(expectedDate) && !isNaN(actualDate)) {
            var delay = dateDiffInDays(expectedDate, actualDate);
            if (!disruptionData[row.Disruption_Type]) {
              disruptionData[row.Disruption_Type] = { total: 0, count: 0 };
            }
            disruptionData[row.Disruption_Type].total += delay;
            disruptionData[row.Disruption_Type].count += 1;
          }
        }
      });
      var avgDisruption = {};
      Object.keys(disruptionData).forEach(function(type) {
        avgDisruption[type] = disruptionData[type].total / disruptionData[type].count;
      });
      var keys = Object.keys(avgDisruption);
      if (keys.length === 0) {
        document.querySelector("#calc-longestDisruption .calc-result").innerHTML = "No data available.";
        return;
      }
      var longestDisruption = keys.reduce(function(a, b) { return avgDisruption[a] > avgDisruption[b] ? a : b; });
      var resultText = "Disruption Type: " + longestDisruption + " (Avg Delay: " + avgDisruption[longestDisruption].toFixed(2) + " days)";
      document.querySelector("#calc-longestDisruption .calc-result").innerHTML = resultText;
    }
    
    // Card 5: Product Category with Shortest Average Lead Time
    function calcShortestProductLead() {
      var productData = {};
      parsedData.forEach(function(row) {
        if (row.Product_Category && row.Order_Date && row.Actual_Delivery_Date) {
          var orderDate = new Date(row.Order_Date);
          var actualDate = new Date(row.Actual_Delivery_Date);
          if (!isNaN(orderDate) && !isNaN(actualDate)) {
            var leadTime = dateDiffInDays(orderDate, actualDate);
            if (!productData[row.Product_Category]) {
              productData[row.Product_Category] = { total: 0, count: 0 };
            }
            productData[row.Product_Category].total += leadTime;
            productData[row.Product_Category].count += 1;
          }
        }
      });
      var avgProduct = {};
      Object.keys(productData).forEach(function(cat) {
        avgProduct[cat] = productData[cat].total / productData[cat].count;
      });
      var keys = Object.keys(avgProduct);
      if (keys.length === 0) {
        document.querySelector("#calc-shortestProduct .calc-result").innerHTML = "No data available.";
        return;
      }
      var shortestProduct = keys.reduce(function(a, b) { return avgProduct[a] < avgProduct[b] ? a : b; });
      var resultText = "Product Category: " + shortestProduct + " (Avg Lead Time: " + avgProduct[shortestProduct].toFixed(2) + " days)";
      document.querySelector("#calc-shortestProduct .calc-result").innerHTML = resultText;
    }
    
    // Card 6: Overall Lead Time Variability
    function calcOverallLeadTimeVar() {
      var leadTimes = [];
      parsedData.forEach(function(row) {
        if (row.LeadTime !== undefined) {
          leadTimes.push(row.LeadTime);
        }
      });
      if (leadTimes.length === 0) {
        document.querySelector("#calc-overallLeadTimeVar .calc-result").innerHTML = "No data available.";
        return;
      }
      var mean = leadTimes.reduce(function(a, b) { return a + b; }, 0) / leadTimes.length;
      var stdDev = Math.sqrt(leadTimes.reduce(function(sum, x) { return sum + Math.pow(x - mean, 2); }, 0) / leadTimes.length);
      document.querySelector("#calc-overallLeadTimeVar .calc-result").innerHTML =
        "Overall Lead Time Variability: " + stdDev.toFixed(2) + " days (Std Dev)";
    }
    
    // Card 7: Transportation Mode with Highest Average Delivery Delay
    function calcHighestTransportDelay() {
      var transportDelayData = {};
      parsedData.forEach(function(row) {
        if (row.Transportation_Mode && row.Expected_Delivery_Date && row.Actual_Delivery_Date) {
          var expectedDate = new Date(row.Expected_Delivery_Date);
          var actualDate = new Date(row.Actual_Delivery_Date);
          if (!isNaN(expectedDate) && !isNaN(actualDate)) {
            var delay = dateDiffInDays(expectedDate, actualDate);
            if (!transportDelayData[row.Transportation_Mode]) {
              transportDelayData[row.Transportation_Mode] = { total: 0, count: 0 };
            }
            transportDelayData[row.Transportation_Mode].total += delay;
            transportDelayData[row.Transportation_Mode].count += 1;
          }
        }
      });
      var avgDelay = {};
      Object.keys(transportDelayData).forEach(function(mode) {
        avgDelay[mode] = transportDelayData[mode].total / transportDelayData[mode].count;
      });
      var keys = Object.keys(avgDelay);
      if (keys.length === 0) {
        document.querySelector("#calc-highestTransportDelay .calc-result").innerHTML = "No data available.";
        return;
      }
      var highestMode = keys.reduce(function(a, b) { return avgDelay[a] > avgDelay[b] ? a : b; });
      var resultText = "Transportation Mode: " + highestMode + " (Avg Delay: " + avgDelay[highestMode].toFixed(2) + " days)";
      document.querySelector("#calc-highestTransportDelay .calc-result").innerHTML = resultText;
    }
    
    // Card 8: Month with Highest Average Lead Time
    function calcHighestLeadTimeMonth() {
      var monthData = {};
      parsedData.forEach(function(row) {
        if (row.Order_Date && row.Actual_Delivery_Date) {
          var orderDate = new Date(row.Order_Date);
          var actualDate = new Date(row.Actual_Delivery_Date);
          if (!isNaN(orderDate) && !isNaN(actualDate)) {
            var leadTime = dateDiffInDays(orderDate, actualDate);
            var month = orderDate.toLocaleString("en-US", { month: "long" });
            if (!monthData[month]) {
              monthData[month] = { total: 0, count: 0 };
            }
            monthData[month].total += leadTime;
            monthData[month].count += 1;
          }
        }
      });
      var avgMonth = {};
      Object.keys(monthData).forEach(function(month) {
        avgMonth[month] = monthData[month].total / monthData[month].count;
      });
      var keys = Object.keys(avgMonth);
      if (keys.length === 0) {
        document.querySelector("#calc-highestLeadTimeMonth .calc-result").innerHTML = "No data available.";
        return;
      }
      var highestMonth = keys.reduce(function(a, b) { return avgMonth[a] > avgMonth[b] ? a : b; });
      var resultText = "Month: " + highestMonth + " (Avg Lead Time: " + avgMonth[highestMonth].toFixed(2) + " days)";
      document.querySelector("#calc-highestLeadTimeMonth .calc-result").innerHTML = resultText;
    }
    
    // Card 9: Bullwhip Effect Analysis
    function calcBullwhipEffect() {
      var monthGroups = {};
      parsedData.forEach(function(row) {
        if (row.Order_Date && row.Order_Quantity !== undefined && row.Customer_Demand !== undefined) {
          var orderDate = new Date(row.Order_Date);
          if (!isNaN(orderDate)) {
            var month = orderDate.toLocaleString("en-US", { month: "long" });
            if (!monthGroups[month]) monthGroups[month] = [];
            monthGroups[month].push(row);
          }
        }
      });
      var tableHTML = "<table><tr><th>Month</th><th>CV(Order Qty)</th><th>CV(Customer Demand)</th><th>Ratio</th></tr>";
      var months = Object.keys(monthGroups);
      if (months.length === 0) {
        document.querySelector("#calc-bullwhip .calc-result").innerHTML = "No data available.";
        return;
      }
      months.forEach(function(month) {
        var rows = monthGroups[month];
        var orderQtys = rows.map(function(r) { return r.Order_Quantity; }).filter(function(val) { return typeof val === "number"; });
        var custDemand = rows.map(function(r) { return r.Customer_Demand; }).filter(function(val) { return typeof val === "number"; });
        if (orderQtys.length === 0 || custDemand.length === 0) return;
        var meanOrder = orderQtys.reduce(function(a, b) { return a + b; }, 0) / orderQtys.length;
        var meanDemand = custDemand.reduce(function(a, b) { return a + b; }, 0) / custDemand.length;
        var stdOrder = Math.sqrt(orderQtys.reduce(function(sum, x) { return sum + Math.pow(x - meanOrder, 2); }, 0) / orderQtys.length);
        var stdDemand = Math.sqrt(custDemand.reduce(function(sum, x) { return sum + Math.pow(x - meanDemand, 2); }, 0) / custDemand.length);
        var cvOrder = meanOrder !== 0 ? stdOrder / meanOrder : 0;
        var cvDemand = meanDemand !== 0 ? stdDemand / meanDemand : 0;
        var ratio = (cvDemand !== 0) ? (cvOrder / cvDemand).toFixed(2) : "N/A";
        tableHTML += "<tr><td>" + month + "</td><td>" + cvOrder.toFixed(2) + "</td><td>" + cvDemand.toFixed(2) + "</td><td>" + ratio + "</td></tr>";
      });
      tableHTML += "</table>";
      document.querySelector("#calc-bullwhip .calc-result").innerHTML = tableHTML;
    }
    
    // Card 10: Correlation between Order Qty Variability and Lead Time Variability
    function calcCorrOrderLeadVar() {
      var supplierGroups = {};
      parsedData.forEach(function(row) {
        if (row.Supplier && row.Order_Quantity !== undefined && row.LeadTime !== undefined) {
          if (!supplierGroups[row.Supplier]) supplierGroups[row.Supplier] = [];
          supplierGroups[row.Supplier].push(row);
        }
      });
      var suppliers = Object.keys(supplierGroups);
      if (suppliers.length < 2) {
        document.querySelector("#calc-corrOrderLeadVar .calc-result").innerHTML = "Insufficient data (need at least 2 suppliers).";
        return;
      }
      var orderStdArray = [];
      var leadStdArray = [];
      suppliers.forEach(function(supplier) {
        var group = supplierGroups[supplier];
        var orderQtys = group.map(function(r) { return r.Order_Quantity; }).filter(function(val) { return typeof val === "number"; });
        var leadTimes = group.map(function(r) { return r.LeadTime; }).filter(function(val) { return typeof val === "number"; });
        if (orderQtys.length === 0 || leadTimes.length === 0) return;
        var meanOrder = orderQtys.reduce(function(a, b) { return a + b; }, 0) / orderQtys.length;
        var meanLead = leadTimes.reduce(function(a, b) { return a + b; }, 0) / leadTimes.length;
        var stdOrder = Math.sqrt(orderQtys.reduce(function(sum, x) { return sum + Math.pow(x - meanOrder, 2); }, 0) / orderQtys.length);
        var stdLead = Math.sqrt(leadTimes.reduce(function(sum, x) { return sum + Math.pow(x - meanLead, 2); }, 0) / leadTimes.length);
        orderStdArray.push(stdOrder);
        leadStdArray.push(stdLead);
      });
      if (orderStdArray.length < 2 || leadStdArray.length < 2) {
        document.querySelector("#calc-corrOrderLeadVar .calc-result").innerHTML = "Insufficient data for correlation.";
        return;
      }
      var corr = pearsonCorrelation(orderStdArray, leadStdArray);
      document.querySelector("#calc-corrOrderLeadVar .calc-result").innerHTML =
        "Pearson Correlation between Order Qty Variability and Lead Time Variability: " + corr.toFixed(3);
    }
    
    // Helper function: Pearson correlation between two arrays
    function pearsonCorrelation(arrX, arrY) {
      var n = arrX.length;
      var meanX = arrX.reduce(function(a, b) { return a + b; }, 0) / n;
      var meanY = arrY.reduce(function(a, b) { return a + b; }, 0) / n;
      var num = 0, denomX = 0, denomY = 0;
      for (var i = 0; i < n; i++) {
        var diffX = arrX[i] - meanX;
        var diffY = arrY[i] - meanY;
        num += diffX * diffY;
        denomX += diffX * diffX;
        denomY += diffY * diffY;
      }
      return num / Math.sqrt(denomX * denomY);
    }
    
    /* ------------------ Chart Visualization Functions ------------------ */
    
    function showChart(type) {
      var ctx, dataObj, canvasId;
      if (type === "supplier") {
        var supplierData = {};
        parsedData.forEach(function(row) {
          if (row.Supplier && row.Order_Date && row.Actual_Delivery_Date) {
            var orderDate = new Date(row.Order_Date);
            var actualDate = new Date(row.Actual_Delivery_Date);
            if (!isNaN(orderDate) && !isNaN(actualDate)) {
              var leadTime = dateDiffInDays(orderDate, actualDate);
              if (!supplierData[row.Supplier]) {
                supplierData[row.Supplier] = { total: 0, count: 0 };
              }
              supplierData[row.Supplier].total += leadTime;
              supplierData[row.Supplier].count += 1;
            }
          }
        });
        dataObj = {};
        Object.keys(supplierData).forEach(function(sup) {
          dataObj[sup] = supplierData[sup].total / supplierData[sup].count;
        });
        canvasId = "chart-highestSupplier";
      } else if (type === "transport") {
        var transportData = {};
        parsedData.forEach(function(row) {
          if (row.Transportation_Mode && row.Order_Date && row.Actual_Delivery_Date) {
            var orderDate = new Date(row.Order_Date);
            var actualDate = new Date(row.Actual_Delivery_Date);
            if (!isNaN(orderDate) && !isNaN(actualDate)) {
              var leadTime = dateDiffInDays(orderDate, actualDate);
              if (!transportData[row.Transportation_Mode]) {
                transportData[row.Transportation_Mode] = { total: 0, count: 0 };
              }
              transportData[row.Transportation_Mode].total += leadTime;
              transportData[row.Transportation_Mode].count += 1;
            }
          }
        });
        dataObj = {};
        Object.keys(transportData).forEach(function(mode) {
          dataObj[mode] = transportData[mode].total / transportData[mode].count;
        });
        canvasId = "chart-lowestTransport";
      } else if (type === "month") {
        var monthData = {};
        parsedData.forEach(function(row) {
          if (row.Expected_Delivery_Date && row.Actual_Delivery_Date) {
            var expectedDate = new Date(row.Expected_Delivery_Date);
            var actualDate = new Date(row.Actual_Delivery_Date);
            if (!isNaN(expectedDate) && !isNaN(actualDate)) {
              var delay = dateDiffInDays(expectedDate, actualDate);
              var month = expectedDate.toLocaleString("en-US", { month: "long" });
              if (!monthData[month]) {
                monthData[month] = { total: 0, count: 0 };
              }
              monthData[month].total += delay;
              monthData[month].count += 1;
            }
          }
        });
        dataObj = {};
        Object.keys(monthData).forEach(function(month) {
          dataObj[month] = monthData[month].total / monthData[month].count;
        });
        canvasId = "chart-highestMonthDelay";
      } else if (type === "disruption") {
        var disruptionData = {};
        parsedData.forEach(function(row) {
          if (row.Disruption_Type && row.Disruption_Type.toLowerCase() !== "none" && row.Expected_Delivery_Date && row.Actual_Delivery_Date) {
            var expectedDate = new Date(row.Expected_Delivery_Date);
            var actualDate = new Date(row.Actual_Delivery_Date);
            if (!isNaN(expectedDate) && !isNaN(actualDate)) {
              var delay = dateDiffInDays(expectedDate, actualDate);
              if (!disruptionData[row.Disruption_Type]) {
                disruptionData[row.Disruption_Type] = { total: 0, count: 0 };
              }
              disruptionData[row.Disruption_Type].total += delay;
              disruptionData[row.Disruption_Type].count += 1;
            }
          }
        });
        dataObj = {};
        Object.keys(disruptionData).forEach(function(type) {
          dataObj[type] = disruptionData[type].total / disruptionData[type].count;
        });
        canvasId = "chart-longestDisruption";
      } else if (type === "product") {
        var productData = {};
        parsedData.forEach(function(row) {
          if (row.Product_Category && row.Order_Date && row.Actual_Delivery_Date) {
            var orderDate = new Date(row.Order_Date);
            var actualDate = new Date(row.Actual_Delivery_Date);
            if (!isNaN(orderDate) && !isNaN(actualDate)) {
              var leadTime = dateDiffInDays(orderDate, actualDate);
              if (!productData[row.Product_Category]) {
                productData[row.Product_Category] = { total: 0, count: 0 };
              }
              productData[row.Product_Category].total += leadTime;
              productData[row.Product_Category].count += 1;
            }
          }
        });
        dataObj = {};
        Object.keys(productData).forEach(function(cat) {
          dataObj[cat] = productData[cat].total / productData[cat].count;
        });
        canvasId = "chart-shortestProduct";
      }
      if (Object.keys(dataObj).length === 0) {
        alert("No data available for chart.");
        return;
      }
      if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
      }
      var ctx = document.getElementById(canvasId).getContext("2d");
      var labels = Object.keys(dataObj);
      var dataValues = labels.map(function(key) { return dataObj[key]; });
      chartInstances[canvasId] = new Chart(ctx, {
        type: "bar",
        data: {
          labels: labels,
          datasets: [{
            label: "Value",
            data: dataValues,
            backgroundColor: "rgba(255,165,0,0.5)",
            borderColor: "rgba(255,165,0,1)",
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          animation: { duration: 1500, easing: "easeOutBounce" },
          plugins: {
            title: { display: true, text: canvasId.replace("chart-", "").replace(/([A-Z])/g, " $1"), color: "#ffa500", font: { size: 18, family: "Orbitron" } },
            legend: { display: false }
          },
          scales: {
            y: { beginAtZero: true, ticks: { color: "#f0f0f0" }, grid: { color: "rgba(255,255,255,0.1)" } },
            x: { ticks: { color: "#f0f0f0" }, grid: { display: false } }
          }
        }
      });
      
      // Apply slide-up and fade-in animation to the chart canvas (identical to other charts)
      var canvasElem = document.getElementById(canvasId);
      canvasElem.style.opacity = 0;
      canvasElem.style.transform = "translateY(50px)";
      setTimeout(function() {
        canvasElem.style.transition = "opacity 0.5s ease, transform 0.5s ease";
        canvasElem.style.opacity = 1;
        canvasElem.style.transform = "translateY(0)";
      }, 50);
    }
    
    /* ------------------ Correlation Analysis Chart ------------------ */
    
    function generateCorrelationChart(xCol, yCol) {
      var xValues = [], yValues = [];
      parsedData.forEach(function(row) {
        if (typeof row[xCol] === "number" && typeof row[yCol] === "number") {
          xValues.push(row[xCol]);
          yValues.push(row[yCol]);
        }
      });
      if (xValues.length === 0 || yValues.length === 0) {
        alert("Insufficient data for correlation chart.");
        return;
      }
      var meanX = xValues.reduce((a, b) => a + b, 0) / xValues.length;
      var meanY = yValues.reduce((a, b) => a + b, 0) / yValues.length;
      var num = 0, denom = 0;
      for (var i = 0; i < xValues.length; i++) {
        var diffX = xValues[i] - meanX;
        var diffY = yValues[i] - meanY;
        num += diffX * diffY;
        denom += Math.pow(xValues[i] - meanX, 2);
      }
      var slope = num / denom;
      var intercept = meanY - slope * meanX;
      var minX = Math.min(...xValues);
      var maxX = Math.max(...xValues);
      var regressionLine = [
        { x: minX, y: slope * minX + intercept },
        { x: maxX, y: slope * maxX + intercept }
      ];
      var scatterData = [];
      for (var i = 0; i < xValues.length; i++) {
        scatterData.push({ x: xValues[i], y: yValues[i] });
      }
      if (chartInstances["chart-correlation"]) {
        chartInstances["chart-correlation"].destroy();
      }
      var ctx = document.getElementById("chart-correlation").getContext("2d");
      chartInstances["chart-correlation"] = new Chart(ctx, {
        type: "scatter",
        data: {
          datasets: [
            {
              label: "Data Points",
              data: scatterData,
              backgroundColor: "rgba(255,165,0,0.5)",
              borderColor: "rgba(255,165,0,1)",
              pointRadius: 4
            },
            {
              label: "Regression Line",
              data: regressionLine,
              type: "line",
              fill: false,
              borderColor: "#ffa500",
              borderWidth: 2,
              pointRadius: 0
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: "Correlation Chart (" + xCol + " vs. " + yCol + ")", color: "#ffa500", font: { size: 18, family: "Orbitron" } },
            legend: { display: true, labels: { color: "#f0f0f0" } }
          },
          scales: {
            x: { title: { display: true, text: xCol, color: "#f0f0f0" }, ticks: { color: "#f0f0f0" } },
            y: { title: { display: true, text: yCol, color: "#f0f0f0" }, ticks: { color: "#f0f0f0" } }
          }
        }
      });
    }
    
    /* ------------------ Custom Visualization ------------------ */
    
    function generateCustomChart() {
      var chartType = document.getElementById("chartTypeSelect").value;
      var xCol = document.getElementById("customXSelect").value;
      var yCol = document.getElementById("customYSelect").value;
      var ctx = document.getElementById("chart-custom").getContext("2d");
      var customData = null;
      if (chartInstances["chart-custom"]) {
        chartInstances["chart-custom"].destroy();
      }
      if (chartType === "histogram") {
        var xData = [];
        parsedData.forEach(function(row) {
          if (typeof row[xCol] === "number") {
            xData.push(row[xCol]);
          }
        });
        if (xData.length === 0) {
          alert("No numeric data available for " + xCol);
          return;
        }
        var bins = 10;
        var minVal = Math.min(...xData);
        var maxVal = Math.max(...xData);
        var binWidth = (maxVal - minVal) / bins;
        var histogram = new Array(bins).fill(0);
        xData.forEach(function(val) {
          var bin = Math.floor((val - minVal) / binWidth);
          if (bin >= bins) bin = bins - 1;
          histogram[bin]++;
        });
        var labels = [];
        for (var i = 0; i < bins; i++) {
          labels.push((minVal + i * binWidth).toFixed(2) + " - " + (minVal + (i+1) * binWidth).toFixed(2));
        }
        customData = {
          labels: labels,
          datasets: [{
            label: "Frequency",
            data: histogram,
            backgroundColor: "rgba(255,165,0,0.5)",
            borderColor: "rgba(255,165,0,1)",
            borderWidth: 1
          }]
        };
      } else if (chartType === "scatter") {
        var scatterData = [];
        parsedData.forEach(function(row) {
          if (typeof row[xCol] === "number" && typeof row[yCol] === "number") {
            scatterData.push({ x: row[xCol], y: row[yCol] });
          }
        });
        if (scatterData.length === 0) {
          alert("Insufficient data for scatter chart.");
          return;
        }
        customData = {
          datasets: [{
            label: xCol + " vs. " + yCol,
            data: scatterData,
            backgroundColor: "rgba(255,165,0,0.5)",
            borderColor: "rgba(255,165,0,1)",
            pointRadius: 4
          }]
        };
      } else if (chartType === "bar" || chartType === "line") {
        var groupData = {};
        parsedData.forEach(function(row) {
          if (typeof row[xCol] === "number" && typeof row[yCol] === "number") {
            var key = row[xCol];
            if (!groupData[key]) groupData[key] = [];
            groupData[key].push(row[yCol]);
          }
        });
        var labels = Object.keys(groupData);
        if (labels.length === 0) {
          alert("Insufficient data for " + chartType + " chart.");
          return;
        }
        var aggregated = labels.map(function(key) {
          var arr = groupData[key];
          return arr.reduce(function(a, b) { return a + b; }, 0) / arr.length;
        });
        customData = {
          labels: labels,
          datasets: [{
            label: xCol + " vs. " + yCol,
            data: aggregated,
            backgroundColor: "rgba(255,165,0,0.5)",
            borderColor: "rgba(255,165,0,1)",
            borderWidth: 1,
            fill: false
          }]
        };
      }
      var config = {
        type: chartType === "line" ? "line" : (chartType === "scatter" ? "scatter" : "bar"),
        data: customData,
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: "Custom Visualization: " + xCol + " vs. " + yCol, color: "#ffa500", font: { size: 18, family: "Orbitron" } },
            legend: { display: false }
          },
          scales: {
            x: {
              ticks: { color: "#f0f0f0" },
              grid: { color: "rgba(255,255,255,0.1)" },
              title: { display: true, text: xCol, color: "#f0f0f0" }
            },
            y: {
              ticks: { color: "#f0f0f0" },
              grid: { color: "rgba(255,255,255,0.1)" },
              title: { display: true, text: yCol, color: "#f0f0f0" }
            }
          }
        }
      };
      chartInstances["chart-custom"] = new Chart(ctx, config);
    }
    
    /* ------------------ Descriptive Statistics and Correlation Functions ------------------ */
    
    function computeDescriptiveStats(column) {
      var values = parsedData.map(function(row) { return row[column]; })
                  .filter(function(val) { return typeof val === "number" && !isNaN(val); });
      if (values.length === 0) return null;
      var mean = values.reduce(function(a, b) { return a + b; }, 0) / values.length;
      var sorted = values.slice().sort(function(a, b) { return a - b; });
      var median = (sorted[Math.floor(values.length / 2)] + sorted[Math.ceil(values.length / 2)]) / 2;
      var mode = modeCalc(values);
      var stdDev = Math.sqrt(values.reduce(function(sum, val) { return sum + Math.pow(val - mean, 2); }, 0) / values.length);
      return { count: values.length, mean: mean, median: median, mode: mode, stdDev: stdDev };
    }
    
    function modeCalc(arr) {
      var frequency = {};
      var maxFreq = 0, mode;
      arr.forEach(function(val) {
        frequency[val] = (frequency[val] || 0) + 1;
        if (frequency[val] > maxFreq) {
          maxFreq = frequency[val];
          mode = val;
        }
      });
      return mode;
    }
    
    function computeCorrelation(xCol, yCol) {
      var xValues = [], yValues = [];
      parsedData.forEach(function(row) {
        if (typeof row[xCol] === "number" && typeof row[yCol] === "number") {
          xValues.push(row[xCol]);
          yValues.push(row[yCol]);
        }
      });
      if (xValues.length === 0 || yValues.length === 0) return null;
      var meanX = xValues.reduce(function(a, b) { return a + b; }, 0) / xValues.length;
      var meanY = yValues.reduce(function(a, b) { return a + b; }, 0) / yValues.length;
      var num = 0, denomX = 0, denomY = 0;
      for (var i = 0; i < xValues.length; i++) {
        var diffX = xValues[i] - meanX;
        var diffY = yValues[i] - meanY;
        num += diffX * diffY;
        denomX += diffX * diffX;
        denomY += diffY * diffY;
      }
      return num / Math.sqrt(denomX * denomY);
    }
  </script>
</body>
</html>